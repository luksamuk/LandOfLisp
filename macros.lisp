;; Get rid of visual noise

(defmacro let1 (var val &body body)
  `(let ((,var ,val))
     ,@body))

(let ((foo (+ 2 3)))
  (* foo foo))

(let1 foo (+ 2 3)
  (* foo foo))


;; see code generated by macro
(macroexpand '(let1 foo (+ 2 3)
	       (* foo foo)))

;; Hint: on SLIME, use C-c RET to macroexpand-1.
;; Or use C-c M-m to macroexpand.
;; More here: https://www.cliki.net/SLIME%20Features

;; List-splitting macro
;; Macros which create variables are ANAPHORIC MACROS

;; Buggy version
;; (defmacro split (val yes no)
;;   `(if ,val
;;        (let ((head (car ,val))
;; 	     (tail (cdr ,val)))
;; 	 ,yes
;; 	 ,no)))

;; Uncomment and pretty-print (C-c C-p on SLIME) to see reason of bug:
;; (macroexpand '(split (progn (princ "Lisp rocks!")
;; 			    '(2 3))
;; 	       (format t "This can be split into ~a and ~a." head tail)
;; 	       (princ "This cannot be split.")))

;; =======

;; Still buggy
;; (defmacro split (val yes no)
;;   `(let1 x ,val
;;      (if x
;; 	 (let ((head (car x))
;; 	       (tail (cdr x)))
;; 	   ,yes
;; 	   ,no))))

;; Uncomment and pp to see reason. Yields an error.
;; (let1 x 100
;;   (split '(2 3)
;; 	 (+ x head)
;; 	 nil))

;; "split" is capturing x accidentally.
;; Therefore, we generate a crazy variable name with gensym so names don't clash


;; Safe macro
(defmacro split (val yes no)
  (let1 g (gensym)
    `(let1 ,g ,val
       (if ,g
	   (let ((head (car ,g))
		 (tail (cdr ,g)))
	     ,yes)
	   ,no))))

;; Testing.
(macroexpand '(split '(2 3)
	       (+ x head)
	       nil))



;; Recursion macro
(defun pairs (list)
  (labels ((f (list acc)
	     (split list
		    (if tail
			(f (cdr tail) (cons (cons head (car tail)) acc))
			(reverse acc))
		    (reverse acc))))
    (f list nil)))


(defmacro recurse (vars &body body)
  (let1 p (pairs vars)
    `(labels ((self ,(mapcar #'car p)
		,@body))
       (self ,@(mapcar #'cdr p)))))

;; Macro usage from book to test.
;; Macroexpand on SLIME with C-c M-m
;; (recurse (n 9)
;;   (fresh-line)
;;   (if (zerop n)
;;       (princ "lift off!")
;;       (progn (princ n)
;; 	     (self (1- n)))))


;; Now we can...
(defun my-length (list)
  (recurse (list list  acc 0)
    (split list
	   (self tail (1+ acc))
	   acc)))



;; However, might be cleaner if we just...
(defun my-length (list)
  (reduce (lambda (x i)
	    (1+ x))
	  list
	  :initial-value 0))


